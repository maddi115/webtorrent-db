// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENTRY_WEBTORRENTDB_H_
#define FLATBUFFERS_GENERATED_ENTRY_WEBTORRENTDB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace WebTorrentDB {

struct Entry;
struct EntryBuilder;

struct Entry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_URL = 4,
    VT_MAGNET = 6,
    VT_TITLE = 8,
    VT_ADDED_BY = 10,
    VT_PREVIEW = 12,
    VT_TIMESTAMP = 14
  };
  const ::flatbuffers::String *source_url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_URL);
  }
  const ::flatbuffers::String *magnet() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAGNET);
  }
  const ::flatbuffers::String *title() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TITLE);
  }
  const ::flatbuffers::String *added_by() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDED_BY);
  }
  const ::flatbuffers::String *preview() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREVIEW);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_URL) &&
           verifier.VerifyString(source_url()) &&
           VerifyOffsetRequired(verifier, VT_MAGNET) &&
           verifier.VerifyString(magnet()) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_ADDED_BY) &&
           verifier.VerifyString(added_by()) &&
           VerifyOffset(verifier, VT_PREVIEW) &&
           verifier.VerifyString(preview()) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct EntryBuilder {
  typedef Entry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source_url(::flatbuffers::Offset<::flatbuffers::String> source_url) {
    fbb_.AddOffset(Entry::VT_SOURCE_URL, source_url);
  }
  void add_magnet(::flatbuffers::Offset<::flatbuffers::String> magnet) {
    fbb_.AddOffset(Entry::VT_MAGNET, magnet);
  }
  void add_title(::flatbuffers::Offset<::flatbuffers::String> title) {
    fbb_.AddOffset(Entry::VT_TITLE, title);
  }
  void add_added_by(::flatbuffers::Offset<::flatbuffers::String> added_by) {
    fbb_.AddOffset(Entry::VT_ADDED_BY, added_by);
  }
  void add_preview(::flatbuffers::Offset<::flatbuffers::String> preview) {
    fbb_.AddOffset(Entry::VT_PREVIEW, preview);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Entry::VT_TIMESTAMP, timestamp, 0);
  }
  explicit EntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Entry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Entry>(end);
    fbb_.Required(o, Entry::VT_SOURCE_URL);
    fbb_.Required(o, Entry::VT_MAGNET);
    return o;
  }
};

inline ::flatbuffers::Offset<Entry> CreateEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> source_url = 0,
    ::flatbuffers::Offset<::flatbuffers::String> magnet = 0,
    ::flatbuffers::Offset<::flatbuffers::String> title = 0,
    ::flatbuffers::Offset<::flatbuffers::String> added_by = 0,
    ::flatbuffers::Offset<::flatbuffers::String> preview = 0,
    int64_t timestamp = 0) {
  EntryBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_preview(preview);
  builder_.add_added_by(added_by);
  builder_.add_title(title);
  builder_.add_magnet(magnet);
  builder_.add_source_url(source_url);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Entry> CreateEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *source_url = nullptr,
    const char *magnet = nullptr,
    const char *title = nullptr,
    const char *added_by = nullptr,
    const char *preview = nullptr,
    int64_t timestamp = 0) {
  auto source_url__ = source_url ? _fbb.CreateString(source_url) : 0;
  auto magnet__ = magnet ? _fbb.CreateString(magnet) : 0;
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto added_by__ = added_by ? _fbb.CreateString(added_by) : 0;
  auto preview__ = preview ? _fbb.CreateString(preview) : 0;
  return WebTorrentDB::CreateEntry(
      _fbb,
      source_url__,
      magnet__,
      title__,
      added_by__,
      preview__,
      timestamp);
}

inline const WebTorrentDB::Entry *GetEntry(const void *buf) {
  return ::flatbuffers::GetRoot<WebTorrentDB::Entry>(buf);
}

inline const WebTorrentDB::Entry *GetSizePrefixedEntry(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<WebTorrentDB::Entry>(buf);
}

template <bool B = false>
inline bool VerifyEntryBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<WebTorrentDB::Entry>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedEntryBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<WebTorrentDB::Entry>(nullptr);
}

inline void FinishEntryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<WebTorrentDB::Entry> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEntryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<WebTorrentDB::Entry> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace WebTorrentDB

#endif  // FLATBUFFERS_GENERATED_ENTRY_WEBTORRENTDB_H_
